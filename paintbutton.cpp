#include <paintbutton.h> //Указываем с чем связан данный файл реализации

PaintButton::PaintButton(QWidget* parent, QImage Res, QRect Source):QPushButton(parent){
    //Реализация конструктора кнопки с картинкой, сначала выполняется унаследованный конструктор родителя - QPushButton, с переданным в него данными родителя

    //!Может быть непонятно
    // this - указатель на текущий экземпляр то есть указывает что допустим в this->Res1, Res1-это именно поле экземпляра класса а не локальная переменная с тем же именем

    this->Res1=Res;//Устанавливаю картинку(текстуру кнопки)
    this->IsRes2=false; //Устанавливаем показатель что кнопка не изменяется при наведении
    this->parent=parent; //Запоминаем родителя объекта
    if (Source.width()==-1) //Если заданный прямоугольник равен начальному значению, то
        this->Source1=Res.rect(); //Устанавливаем прямоугольник, как размер всего изображения
    else //Иначе
        this->Source1=Source; //Сохраняем прямоугольник отображения
    T_Cursor=new QTimer(this); //Создаём экземпляр стандартного класса Qt таймер , привязанного к текущему экземпляру
    connect(T_Cursor, SIGNAL(timeout()), this, SLOT(Tick_T())); //связываем прохождение интервала таймера со слотом экземпляра
    T_Cursor->start(10); //Запускаем таймер, который каждые 10 миллисекунд будет отправлять сигнал timeout()
}

PaintButton::PaintButton(QWidget* parent, QImage Res1, QImage Res2, QRect Source1, QRect Source2):QPushButton(parent){
    //Реализация конструктора кнопки с картинкой, сначала выполняется унаследованный конструктор родителя - QPushButton, с переданным в него данными родителя

    this->Res1=Res1; //Устанавливаю картинку(текстуру по умолчанию кнопки)
    this->parent=parent; //Запоминаем родителя объекта
    this->IsRes2=true; //Устанавливаем показатель что кнопка изменяется при наведении
    if (Source1.width()==-1) //Если заданный прямоугольник равен начальному значению, то
        this->Source1=Res1.rect(); //Устанавливаем прямоугольник, как размер всего изображения
    else //Иначе
        this->Source1=Source1; //Сохраняем прямоугольник отображения
    this->Res2=Res2; //Устанавливаю картинку(текстуру при наведении на кнопку)
    if (Source2.width()==-1) //Если заданный прямоугольник равен начальному значению, то
        this->Source2=Res2.rect(); //Устанавливаем прямоугольник, как размер всего изображения
    else //Иначе
        this->Source2=Source2; //Сохраняем прямоугольник отображения
    T_Cursor=new QTimer(this); //Создаём экземпляр стандартного класса Qt таймер , привязанного к текущему экземпляру
    connect(T_Cursor, SIGNAL(timeout()), this, SLOT(Tick_T())); //связываем прохождение интервала таймера со слотом экземпляра
    T_Cursor->start(10); //Запускаем таймер, который каждые 10 миллисекунд будет отправлять сигнал timeout()
}

void PaintButton::paintEvent(QPaintEvent *event){ //Реализация функции отрисовки объекта
    QPainter p(this); //Создаём устройство для рисование нацеленное на конкретный экземпляр данного класса
    if (Enter && IsRes2) //Если мышка внутри и указано что кнопка изменяется при наведении
        p.drawImage(QRect(0,0, this->width(), this->height()), Res2, Source2); //Рисуем текстуру при наведении из указанного прямоугольника
    else //Иначе
        p.drawImage(QRect(0,0, this->width(), this->height()), Res1, Source1); //Рисуем текстуру по умолчанию из указанного прямоугольника
    p.setFont(this->font()); //Устанавливаем шрифт рисуемого текста
    p.drawText(QRect(0, 0, this->width(), this->height()), Qt::AlignCenter, this->text()); //Рисуем видимый текст, немного отступая от краёв, установив выравнивание по центру
}

void PaintButton::Tick_T(){ //Функция обработки позиции курсора относительно элемента
    bool EnterInRect=QCursor::pos().x()-parent->x()-this->x()>=0 && QCursor::pos().x()-parent->x()-this->x()<this->width() &&
            QCursor::pos().y()-24-parent->y()-this->y()>0 && QCursor::pos().y()-24-parent->y()-this->y()<this->height();
    //Узнаём находится ли курсор в пределах элемента, QCursor::pos()-возвращает глобальные координаты(т.е. относительно всего экрана)
    if (EnterInRect && Enter==false){ //Если показатель выше верен и ранее мышка не была внутри элемента
        Enter=true; //То устанавливаем показатель нахождения курсора внутри
        repaint(); //Перерисовываем элемент
    }else if(!EnterInRect && Enter==true){ //Иначе если кусор не внутри но в прошлый момент времени был внутри, то
        Enter=false; //Устанавливаем показатель отсутсвия курсора внутри
        repaint(); //Перерисовываем элемент
    }
}
