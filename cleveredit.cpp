#include <cleveredit.h> //Указываем с чем связан данный файл реализации

CleverEdit::CleverEdit(QWidget* parent, QString Text, EchoMode EcMo, bool (*ValidFunc)(QString), bool SpaceLegal):QLineEdit(parent)
//Реализация конструктора Умного поля для ввода, сначала выполняется унаследованный конструктор родителя - QLineEdit, с переданным в него данными родителя
{
    //!Может быть непонятно
    // this - указатель на текущий экземпляр то есть указывает что допустим в this->SpaceLegal, SpaceLegal-это именно поле экземпляра класса а не локальная переменная с тем же именем

    this->SpaceLegal=SpaceLegal; //Устанавливаем значение легально ли использование пробелов и подобных символов
    this->ValidFunc=ValidFunc; //Устанавливаем функцию проверяющую содержащийся текст
    this->setEchoMode(EcMo); //Установка правил на отображение и копирование
    this->setFont(QFont(this->font().family(), this->font().pointSize()+6, this->font().weight()+6)); //Увеличиваем размер шрифта по умолчанию на 6
    this->HelpText=new QLabel(this); //Указатель на надпись привязываем к созданной надписи, дочерней к конкретному экземпляру
    this->HelpText->setText(Text); //Устанавливаем текст надписи(подсказки)
    HelpText->setStyleSheet("color: lightGray"); //Устанавливаем цвет текста(подсказки) светло-серый
    QValidator * validator = new QRegExpValidator(QRegExp("\\w+")); /* Регулярное выражерние \w означает любой символ который может содержаться в слове, а + что символов 1 и больше
                                                                     * Те, данное выражение соответсвует одному слову собранному из любых непробленых символов
                                                                     */
    if (!SpaceLegal) //если пробелы запрещены
        this->setValidator(validator); //отключаем возможность ввода пробелов табов и тд
    HelpText->setAlignment(Qt::AlignCenter); //устанавливаем выравнивание по центру
    this->setGeometry(0,0, width(), height()); //Растгиваем надпись с подсказкой по размеру поля для ввода
    connect(T_paintActivPosition, SIGNAL(timeout()), this, SLOT(Tick_T_paintActivPosition())); //связываем прохождение интервала таймера с функцией
    State=(*ValidFunc)(this->text())+1; //Устанавливаем состояние поля для ввода
    repaint(); //Перерисовываем объект
}

void CleverEdit::paintEvent(QPaintEvent* event){ //Реализация функции отрисовки объекта, принадлежащей пространству имён класса CleverEdit
    QPainter p(this); //Создаём устройство для рисование нацеленное на конкретный экземпляр данного класса
    p.setPen(QPen(Qt::white, 3)); //Устанавливаем цвет и ширину "Ручки" рисователя(то чем рисуются линии, контур и текст)
    p.setBrush(QBrush(Qt::black)); //Устанавливаем цвет "Кисти" рисователя(то чем заливается фон рисуемых элементов)
    if (!State){ //Если состояние соответсвует активно-вводимому тексту, то
        p.drawRect(0,0, this->width()-2, this->height()-2); //Просто рисуем прямоугольник размером во весь элемент, с белыми краями(цвет устанавливали выше)
    }else if (State==QValidator::Acceptable){ //Иначе если состояние соответсвует тексту верного формата, то
        p.setPen(QPen(Qt::green, 3)); //Устанавливаем цвет и ширину "Ручки"
        p.drawRect(0,0, this->width()-2, this->height()-2); //Рисуем прямоугольник размером во весь элемент, с зелёными краями
    }else{ //Иначе (состояние соответсвует тексту неверного формата)
        p.setPen(QPen(Qt::red, 3)); //Устанавливаем цвет и ширину "Ручки"
        p.drawRect(0,0, this->width()-2, this->height()-2); //Рисуем прямоугольник размером во весь элемент, с красными краями
    }
    p.setPen(QPen(Qt::white, 2)); //Устанавливаем цвет и ширину "Ручки", для последуещего рисования им текста
    if (this->text()!=""){ //Если введённый текст не пустой, то
        HelpText->hide(); //Прячем надпись с подсказкой
        QString VisibleText=this->text(); //Устанавливаем изначально что весь текст в элементе является видимым(влазит в границы объекта)
        if (this->echoMode()==CleverEdit::Password){ //Если режим отображения и копирования установлен как у пароля(наследован от QLineEdit), то
            QString temp(this->text().length(), '*'); //Переменной ставим соответсвие символы звёздочек той же длинны что и содержащийся текст
            VisibleText=temp; //Указываем что видимый Текст теперь является звёздочками(прямо как ты :) )
        }
        for (;;){ //Запускаем цикл без условия
            QFontMetrics fm(this->font()); //Создаём инструмент для работы со шрифтами по текущему шрифту элемента
            if (fm.width(VisibleText)<this->width()) break; //Если ширина видимого текста в данном шрифте меньше ширины объекта, то выходим из цикла
            VisibleText=VisibleText.left(VisibleText.length()-1); //(иначе)Удаляем последний символ из видимого текста
        }
        p.setFont(this->font()); //Устанавливаем шрифт рисуемого текста, равный шрифту объекта
        QFontMetrics fm(this->font()); //Создаём инструмент для работы со шрифтами по текущему шрифту элемента
        if (this->selectionLength()>0 && Activ){ //Если длинна выделенного текста не 0 и если объект является активным, то
            QPen buffPen=p.pen(); //Сохраняем настройки устройства для рисования
            p.setBrush(Qt::darkBlue); //Устанавливаем цвет заливки
            int xBeginOfText=(this->width()-fm.width(VisibleText))/2; //Узнаём позицию по х, соответсвующую началу рисования текста для расположения его по центру
            int yOfText=(this->height()-fm.height())/2; //Узнаём позицию по х, соответсвующую началу рисования текста для расположения его по центру
            p.drawRect(xBeginOfText+fm.width(VisibleText.left(this->selectionStart())), yOfText-3, fm.width(VisibleText.mid(this->selectionStart(), this->selectionLength())), fm.height()+6);
            /*Рисуем прямоугольник(задаём координаты лево-верхней вершины, ширину и высоту, в качестве х вершины - xBeginOfText+ширина текста до выделенной области,
             * у вершины - yOfText-3 чтобы область выделения была немного больше границы букв, ширины - ширина текста являющимся выделенным, высоты - ...
             */

            p.setPen(buffPen);//восстанавливаем настройки рисователя
        }
        p.drawText(QRect(2, 1, this->width()-4, this->height()-2),Qt::AlignCenter, VisibleText); //Рисуем видимый текст, немного отступая от краёв, установив выравнивание по центру

        if (Activ && Ok_forTF){ //Если экземпляр активен и есть необходимость смены фазы отображении курсора, то
            if (stepOfPaint){ //Если фаза моргания подразумевает отрисовку
                QFontMetrics fm(this->font()); //Создаём инструмент для работы со шрифтами по текущему шрифту элемента
                p.setPen(QPen(QBrush(Qt::white), 2)); //Устанавливаем настройки устройства для рисования
                int x=(this->width()-fm.width(VisibleText))/2+fm.width(VisibleText.left(this->cursorPosition()));
                /*Значению соответсвует начало текста выровненного по центру + ширина сиволов идущих до позиции курсора в установленном шрифте
                 */

                p.drawLine(x, (this->height()-fm.height())/2, x, (this->height()-fm.height())/2+fm.height()); //рисуем чёрточку курсора
            }
            stepOfPaint=!stepOfPaint; //Меняем фазу моргания
        }
    }else{ //Если введённый текст пустой
        if (!Activ) //Если экземпляр не активен, то
            HelpText->show(); //Показываем надпись с подсказкой для ввода
        else if (Ok_forTF){ //Если экземпляр активен и необходимо сменить фазу моргания, то
            HelpText->hide(); //Прячем надпись подсказки
            if (stepOfPaint){ //Если фаза соответсвует отрисовке курсора, то
                QFontMetrics fm(this->font()); //Устанавливаем настройки устройства для рисования
                p.setPen(QPen(QBrush(Qt::white), 2));//Устанавливаем настройки устройства для рисования
                p.drawLine(this->width()/2, (this->height()-fm.height())/2, this->width()/2, (this->height()-fm.height())/2+fm.height()); //рисуем чёрточку курсора
            }
            stepOfPaint=!stepOfPaint; //Меняем фазу моргания
        }
    }
}

void CleverEdit::resizeEvent(QResizeEvent *event){ //Переопределённая функция объекта QAbstractItem, вызывающаяся когда происходит изменение размера экземпляра класса
    HelpText->resize(width(), height()); //Растягиваем надпись подсказке по новому(изменеённому) размеру экземпляра
}

void CleverEdit::mousePressEvent(QMouseEvent *e){ //Переопределённая функция объекта QAbstractButton, вызывающаяся когда на экземпляр данного класса тыкнули мышкой
    Activ=1; //Установить что сейчас экземпляр является активным
    State=0; //Установить состояние соответствующее непосредственно редактированию текста
    T_paintActivPosition->start(360); //Запуск таймера, где каждые 360 милисекунд отправляется сигнал timeout()
}

void CleverEdit::focusOutEvent(QFocusEvent *e){ //Переопределённая функция объекта QAbstractButton, вызывающаяся когда статус активного переходит на любой другой объект
    T_paintActivPosition->stop(); //Останавливаем таймер, останавливая моргание курсора
    Activ=false; stepOfPaint=false; //Указываем что экземпляр не активен и что фаза моргания не соответсвует рисованию курсора
    State=(*ValidFunc)(this->text())+1; //Устанавливаем состояние экземпляра по валидации его содержимого
    repaint(); //вызываем функцию перерисовки
}

void CleverEdit::focusInEvent(QFocusEvent *e){ //Переопределённая функция объекта QAbstractButton, вызывающаяся когда статус активного переходит на экземпляр
    Activ=1; //Установить что сейчас экземпляр является активным
    State=0; //Установить состояние соответствующее непосредственно редактированию текста
    T_paintActivPosition->start(360); //Запуск таймера, где каждые 360 милисекунд отправляется сигнал timeout()
}

int CleverEdit::GetState(){ //Геттер состояния элемнта
    return State; //возврат значения приватной переменной
}

void CleverEdit::SetValidFunc(bool (*ValidFunc)(QString)){ //Функция установки функции валидации
    this->ValidFunc=ValidFunc; //Установка значения приватного поля
}

