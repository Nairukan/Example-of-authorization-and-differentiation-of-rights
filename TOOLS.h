#ifndef TOOLS_H
#define TOOLS_H


#include <fstream> //Подключение библиотеки работы с файлами
#include <QString> //Подключение стандартного класса(типа) QString
#include <MACRO_FOR_RUN.h> //Подключаем библиотеку содержащую макросы, управляющие выполнением программы


#ifdef DEBAG //Если включён режим отладки в MACRO_FOR_RUN
    #include <iostream> //Подключаем библиотеку работы с консолью
#endif //конец условия


class TOOLS{ //Класс содержащий множество статических(которые можно вызвать без создания экземпляра) полезных функций
public: //Функции и члены доступные извне данного класса
    static int Len(char* a){ //Статическая функция возвращающая длинну массива символов
        int i=0; //Объявляем начальную длинну равную 0
        while (a[i++]!=0); //Пока не встретиться нуль-символ повторяем, увеличивая длинну
        return i; //Возвращаем кол-во символов до нуль-символа
    }

    static char* StdStringToChar(std::string a){ //Функция перевода std::string к массиву символов
        char* al=new char[a.length()+1]; //выделяем память под кол-во символов в строке + 1 на нуль-символ
        for (int i=0; i<a.length(); i++){ //Проходим по всем символам std::string
            al[i]=a[i]; //перенося их значения в массив символов но соответствующие позиции
        }
        al[a.length()]=0; //Так же в конце скопированного содержимого дописываем нуль-символ
        return al; //возвращаем получившийся массив символов
    }

    static std::string CharToStdString(char* a){ //Функция перевода массива символов к std::string
        std::string al; //объявляем пусстой элемент типа std::string
        for (int i=0; i<Len(a)-1; i++) //проходим по всем символам массива кроме последнего т.к. тот является нуль-символом
            al+=a[i]; //Дописываем в конец строки очередной символ из массива
        return al; //возвращаем получившуюся строку
    }

    template <typename T> //Объявляем создание шаблона функции где тип переменных T, является произвольным
    static T BinaryRead(std::fstream* OpenIn, T readInfo){ /*Функция возвращающая результат чтения из открытого бинарного файла,
                                                            *В качестве параметров: указатель на соответсвующий фаловый поток бинарного файла, и экземпляр типа необходимого для считывания
                                                            */

        OpenIn->read((char*)(&readInfo), sizeof(readInfo)); /*Считываем из бинарного потока информацию, длинной в sizeof(readInfo),где sizeof возвращает кол-во байт занимаемых этим типом,
                                                             *в адресс где хранится переменная readInfo(адресс переводится в формат байтов в с++ char* выполняет роль так же byte*)
                                                             */

        return readInfo; //возвращаем считанную информацию
    }

    template <typename T> //Объявляем создание шаблона функции где тип переменных T, является произвольным
    static void BinaryWrite(std::fstream* OpenOut, T outInfo){ //Функция записывающая в открытый бинарный файл некоторую информацию, (-\\-)
        OpenOut->write((char*)&outInfo, sizeof(outInfo)); /*Записываем в бинарный файл информацию, из адресса где хранится переменная readInfo(&<имя переменной>-возвращает адресс переменной)
                                                           *длинной в sizeof(readInfo),где sizeof возвращает кол-во байт занимаемых этим типом,
                                                           */
    }

#ifdef DEBAG //Если включён режим отладки в MACRO_FOR_RUN
    template <typename T>  //Объявляем создание шаблона функции где тип переменных T, является произвольным
    static void PrintWhatRead(std::fstream* OpenIn, T readInfo){ //Функция в которой результат чтения из открытого бинарного файла в виде текста в консоли
        OpenIn->read((char*)(&readInfo), sizeof(readInfo)); //Считываем из бинарного потока информацию
        std::cout << "\"" << readInfo << "\" "; //Выводим её в консоль
    }
#endif //Конец условия
};

#endif // TOOLS_H
